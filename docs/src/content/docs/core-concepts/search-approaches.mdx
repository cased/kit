---
title: Searching
---

Not sure **which `kit` feature to reach for**?  Use this page as a mental map of
search-and-discovery tools – from plain-text grep all the way to LLM-powered
semantic retrieval.

> **Tip:** You can mix-and-match different search approaches. For instance, run a docstring search first,
> then feed the matching files into `ContextAssembler` for an LLM chat.

## Approaches in detail

### 1. Plain-text / regex search

Fast, zero-setup, works everywhere. Use when you *know* what string you're
looking for.

```python
repo.search_text("parse_jwt", file_pattern="*.py")
```

### 2. AST-based pattern search

Find code by its structure using Abstract Syntax Tree patterns. Perfect for
finding specific code constructs like async functions, error handlers, or
class inheritance patterns.

```python
from kit.ast_search import ASTSearcher
searcher = ASTSearcher(repo)
# Find all async functions
results = searcher.search_pattern("async def", mode="simple")
```

### 3. Symbol indexing

`extract_symbols()` uses **tree-sitter** queries (Python, JS, Go, etc.) to list
functions, classes, variables – handy for nav trees or refactoring tools.

### 4. LLM summarization

Generate natural-language summaries for files, classes, or functions with
`Summarizer`.  Great for onboarding or API docs.

### 5. Vector search (raw code)

`VectorSearcher` chunks code (symbols or lines) → embeds chunks → stores them in
a local vector database.  Good when wording of the query is *similar* to the
code.

### 6. Docstring vector search

`DocstringIndexer` first *summarizes* code, then embeds the summary.  The
resulting vectors capture **intent**, not syntax; queries like “retry back-off
logic” match even if the code uses exponential delays without those words.

---

Still unsure?  Start with text-search (cheap), move to vector search (smart),
and layer summaries when you need *meaning* over *matching*.
